---
title: 'Introduction to R Tutorial'
author: "DS-SL"
date: "{r Sys.Date()}`"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: >
  Learn how to use R on RStudio using the tidyverse package.
---

```{r my_setup, include=FALSE}
Sys.setenv(LANG = "en")
```

```{r setup1, include=FALSE}
library(learnr)
tutorial_options(exercise.timelimit = 60)
```

## I. R Basic

### Outline

We will learn the basics of R in this tutorial.

* Arithmetic: addition $+$, subtraction $-$, multiplication by $*$, division by $/$, and a power.
* A row of numbers or characters called a vector. 
* A rectangular array of numbers or characters called a data frame.
* and related topics.

You can skip this tutorial if you already know above.

### Is this tutorial for you?

Do you need to work through the tutorial? Take the quiz below to find out.


```{r quiz1, echo = FALSE}
question("Check all that you have NOT done:",
  answer("installed R on my computer", message = "* Install R"),
  answer("installed the RStudio IDE", message = "* Install RStudio IDE"),
  answer("installed the tidyverse R package", message = "* Install Packages"),
  answer("None of the above. I've done them all.", correct = TRUE, message = "You can skip this tutorial!"),
  type = "multiple",
  incorrect = "This tutorial is here to help! To get set up read:"
)
```

## II. Preinstalled Dataset

### How to install R

![](https://vimeo.com/203516510)

### Test your knowledge

```{r quiz2, echo=FALSE}
quiz(caption = "Quiz - Install R",
  question("Is R free to download and use?",
    answer("Yes!", correct = TRUE, message = "R is free _and_ open source, which means that anyone can read, use, and copy the source code of the R language."),
    answer("No.")
  ),
  question("Where do you download R?",
    answer("www.rstudio.com/download"),
    answer("[cloud.r-project.org](http://cloud.r-project.org)", correct = TRUE, message = "You can also download R from [cran.r-project.org](http://cran.r-project.org)"),
    answer("www.r-project.org", message = "Good try, but not exactly. www.r-project.org doesn't provide a download link, but it does provide a link to one the websites above."),
    answer("www.r.com"),
    allow_retry = TRUE
  ),
  question("How often should you update R?",
    answer("Everytime you use it", message = "This will be too often unless you use R very rarely!"),
    answer("About once a year", correct = TRUE, "A new version of R is released about once a year. Update sooner if you encounter a bug that you cannot explain."),
    answer("Never", message = "A new version of R is released about once a year. I'll assume that you are using the newest version of R, which will be the fastest version with the fewest unexpected behaviors." ),
    allow_retry = TRUE
  )
)
```

## WDI Data, I

### How to install RStudio

RStudio is an Integrated Development Environment for R. What does that mean? Well, if you think of R as a language, which it is, you can think of RStudio as a program that helps you write and work in the language. RStudio makes programming in R much easier and I suggest that you use it!

![](https://vimeo.com/203516968)

### Test your knowledge

```{r quiz3, echo=FALSE}
quiz(caption = "Quiz - Install RStudio",
  question("What is the RStudio IDE?",
    answer("An application that makes it easier to use R.", correct = TRUE, message = "RStudio organizes your workspace and makes it easier to write, use, debug, and save R code. I highly recommend it and will rely on the RStudio IDE in several tutorials."),
    answer("An application that let's you use R without writing any code", message = "And thank goodness! Code provides a reproducible record of your work, which is essential for data science."),
    answer("A spreadsheet program like Microsoft Excel."),
    answer("Another name for R", message = "R and RStudio are two separate things. R is a language, like English. Think of RStudio as a program that helps you use the language, kind of like how a word processing program helps you write in English."),
    allow_retry = TRUE
  ),
  question("Is the RStudio IDE free to download and use?",
    answer("Yes!", correct = TRUE, message = "Like R, RStudio is free and open-source. There do exist professional versions of RStudio with enhanced features, but we will not rely on those features in these tutorials."),
    answer("No.", message = "Like R, RStudio is free and open-source. There do exist professional versions of RStudio with enhanced features, but we will not rely on those features in these tutorials.")
  ),
  question("Where do you download RStudio?",
    answer("www.rstudio.com/download", correct = TRUE, message = "For these tutorials, download and install the RStudio Desktop Open Source License."),
    answer("[cloud.r-project.org](http://cloud.r-project.org)", message = "This is where you download R, not RStudio."),
    answer("www.r-project.org"),
    answer("[cran.rstudio.org](http://cran.rstudio.org)"),
    allow_retry = TRUE
  ),
  question("Do you need to install R if you already have RStudio?",
    answer("Yes.", correct = TRUE),
    answer("No.", message = "R does not come with RStudio; you need to install R separately.")
  )
)
```

## WDI Date, II

### How to install R packages

![](https://vimeo.com/203516241)

### Test your knowledge

```{r names, echo = FALSE}
quiz(caption = "Quiz - Working with Packages",
  question("What command do you use to install packages?",
    answer("`library()`", message = "We will see what `library()` does later."),
    answer("`install.packages()`", correct = TRUE),
    answer("`install_packages()`"),
    answer("There is no command. You must visit [cran.r-project.org](http://cran.r-project.org) and download packages manually.", message = "R makes it easy to download packages. You connect to the internet and then run one of the commands above."),
    allow_retry = TRUE
  ),
  question("How often do you need to install a package on your computer?",
    answer("Every time you restart R"),
    answer("Every time you restart your computer"),
    answer("Only once. Afterwards, R can find it on your hard drive as needed.", correct = TRUE),
    answer("Never, as long as you are connected to the internet.", message = "This could be true if you are using R over a cloud service. However, if you are using R locally on your own computer, you will need to install each package that you use on your computer."),
    allow_retry = TRUE
  ),
  question("What is the tidyverse?",
    answer("A collection of packages that work well together and provide tools for common data science tasks.", correct = TRUE, message = 'You can install all of the tidyverse packages at once with `install.packages("tidyverse")`.'),
    answer("A word processing program for R"),
    answer("A code style that reads like poetry"),
    answer("An alternate universe where everyone is an R programmer."),
    allow_retry = TRUE
  )
)
```



```{r setup2, include=FALSE}
library(learnr)
library(tidyverse)
library(nycflights13)
library(Lahman)
tutorial_options(
  exercise.timelimit = 60,
  # A simple checker function that just returns the message in the check chunk
  exercise.checker = function(check_code, ...) {
    list(
      message = eval(parse(text = check_code)),
      correct = logical(0),
      type = "info",
      location = "append"
    )
  }
)
knitr::opts_chunk$set(error = TRUE)
```

## II. Filtering Observations

This is a demo tutorial. Compare it to the [source code](https://github.com/rstudio/learnr/tree/main/inst/tutorials/ex-data-filter/ex-data-filter.Rmd) that made it.

###

In this tutorial, you will learn how to:

* use `filter()` to extract observations from a data frame or tibble
* write logical tests in R
* combine logical tests with Boolean operators
* handle missing values within logical tests

The readings in this tutorial follow [_R for Data Science_](http://r4ds.had.co.nz/), section 5.2.

### Prerequisites

To practice these skills, we will use the `flights` data set from the nycflights13 package. This data frame comes from the US [Bureau of Transportation Statistics](http://www.transtats.bts.gov/DatabaseInfo.asp?DB_ID=120&Link=0) and contains all `r format(nrow(nycflights13::flights), big.mark = ",")` flights that departed from New York City in 2013. It is documented in `?flights`.

We will also use the ggplot2 package to visualize the data.

If you are ready to begin, click on!

## Filter rows with `filter()`

### filter()

`filter()` lets you use a logical test to extract specific rows from a data frame. To use `filter()`, pass it the data frame followed by one or more logical tests. `filter()` will return every row that passes each logical test.

So for example, we can use `filter()` to select every flight in flights that departed on January 1st. Click Run Code to give it a try:

```{r filter1, exercise = TRUE, exercise.eval = FALSE}
filter(flights, month == 1, day == 1)
```


###  output

Like all dplyr functions, `filter()` returns a new data frame for you to save or use. It doesn't overwrite the old data frame.

If you want to save the output of `filter()`, you'll need to use the assignment operator, `<-`.

Rerun the command in the code chunk below, but first arrange to save the output to an object named `jan1`.

```{r filter2, exercise = TRUE, exercise.eval = FALSE}
filter(flights, month == 1, day == 1)
```

```{r filter2-solution}
jan1 <- filter(flights, month == 1, day == 1)
```

###

Good job! You can now see the results by running the name jan1 by itself. Or you can pass `jan1` to a function that takes data frames as input.

Did you notice that this code used the double equal operator, `==`? `==` is one of R's logical comparison operators. Comparison operators are key to using `filter()`, so let's take a look at them.

## Logical Comparisons

### Comparison operators

R provides a suite of comparison operators that you can use to compare values: `>`, `>=`, `<`, `<=`, `!=` (not equal), and `==` (equal). Each creates a logical test. For example, is `pi` greater than three?

```{r}
pi > 3
```

###

When you place a logical test inside of `filter()`, filter applies the test to each row in the data frame and then returns the rows that pass, as a new data frame.

Our code above returned every row whose month value was equal to one _and_ whose day value was equal to one.

### Watch out!

When you start out with R, the easiest mistake to make is to test for equality with `=` instead of `==`. When this happens you'll get an informative error:

```{r, error = TRUE}
filter(flights, month = 1)
```

### Multiple tests

If you give `filter()` more than one logical test, `filter()` will combine the tests with an implied "and." In other words, `filter()` will return only the rows that return `TRUE` for every test. You can combine tests in other ways with Boolean operators...

## Boolean operators

### &, |, and !

R uses boolean operators to combine multiple logical comparisons into a single logical test. These include `&` (_and_), `|` (_or_), `!` (_not_ or _negation_), and `xor()` (_exactly or_).

Both `|` and `xor()` will return TRUE if one or the other logical comparison returns TRUE. `xor()` differs from `|` in that it will return FALSE if both logical comparisons return TRUE. The name _xor_ stands for _exactly or_.

Study the diagram below to get a feel for how these operators work.

```{r fig1, echo = FALSE, out.width = "100%", fig.cap = "In the figure above, `x` is the left-hand circle, `y` is the right-hand circle, and the shaded region show which parts each command selects."}
knitr::include_graphics("images/transform-logical.png")
```

### Test Your Knowledge

```{r logicals, echo = FALSE}
question(" What will the following code return? `filter(flights, month == 11 | month == 12)`",
         answer("Every flight that departed in November _or_ December", correct = TRUE),
         answer("Every flight that departed in November _and_ December", message = "Technically a flight could not have departed in November _and_ December unless it departed twice."),
         answer("Every flight _except for_ those that departed in November or December"),
         answer("An error. This is an incorrect way to combine tests.", message = "The next section will say a little more about combining tests."),
         allow_retry = TRUE
)
```

### Common mistakes

In R, the order of operations doesn't work like English. You can't write `filter(flights, month == 11 | 12)`, even though you might say  "finds all flights that departed in November or December". Be sure to write out a _complete_ test on each side of a boolean operator.

Here are four more tips to help you use logical tests and Boolean operators in R:

###

1. A useful short-hand for this problem is `x %in% y`. This will select every row where `x` is one of the values in `y`. We could use it to rewrite the code in the question above:

    ```{r, eval = FALSE}
    nov_dec <- filter(flights, month %in% c(11, 12))
    ```

###

2. Sometimes you can simplify complicated subsetting by remembering De Morgan's law: `!(x & y)` is the same as `!x | !y`, and `!(x | y)` is the same as `!x & !y`. For example, if you wanted to find flights that weren't delayed (on arrival or departure) by more than two hours, you could use either of the following two filters:

    ```{r, eval = FALSE}
    filter(flights, !(arr_delay > 120 | dep_delay > 120))
    filter(flights, arr_delay <= 120, dep_delay <= 120)
    ```

###

3. As well as `&` and `|`, R also has `&&` and `||`. Don't use them with `filter()`! You'll learn when you should use them later.

###

4. Whenever you start using complicated, multipart expressions in `filter()`, consider making them explicit variables instead. That makes it much easier to check your work. You'll learn how to create new variables shortly.

## Missing values

### NA

Missing values can make comparisons tricky in R. R uses `NA` to represent missing or unknown values. `NA`s are "contagious" because almost any operation involving an unknown value (`NA`) will also be unknown (`NA`). For example, can you determine what value these expressions that use missing values should evaluate to? Make a prediction and then click "Submit Answer".

```{r nas, exercise = TRUE}
NA > 5
10 == NA
NA + 10
NA / 2
NA == NA
```

```{r nas-check}
"In every case, R does not have enough information to compute a result. Hence, each result is an unknown value, `NA`."
```

### is.na()

The most confusing result above is this one:

```{r}
NA == NA
```

It's easiest to understand why this is true with a bit more context:

```{r}
# Let x be Mary's age. We don't know how old she is.
x <- NA
# Let y be John's age. We don't know how old he is.
y <- NA
# Are John and Mary the same age?
x == y
# We don't know!
```

If you want to determine if a value is missing, use `is.na()`:

```{r}
is.na(x)
```

### filter() and NAs

`filter()` only includes rows where the condition is `TRUE`; it excludes both `FALSE` and `NA` values. If you want to preserve missing values, ask for them explicitly:

```{r}
df <- tibble(x = c(1, NA, 3))
filter(df, x > 1)
filter(df, is.na(x) | x > 1)
```

## Exercises

### Exercise 1

Use the code chunks below to find all flights that

1. Had an arrival delay of two or more hours

    ```{r filterex1, exercise = TRUE}
    ```
    ```{r filterex1-solution}
    filter(flights, arr_delay >= 120) # arr_delay is in minutes
    ```

1. Flew to Houston (`IAH` or `HOU`)

    ```{r filterex2, exercise = TRUE}
    ```
    ```{r filterex2-solution}
    filter(flights, dest %in% c("IAH", "HOU"))
    ```

    <div id="filterex2-hint">
    **Hint:** This is a good case for the `%in%` operator.
    </div>

1. Were operated by United (`UA`), American (`AA`), or Delta (`DL`)

    ```{r filterex3, exercise = TRUE}
    ```
    ```{r filterex3-solution}
    filter(flights, carrier %in% c("UA", "AA", "DL"))
    ```

    <div id="filterex3-hint">
    **Hint:** The `carrier` variable lists the airline that operated each flight. This is another good case for the `%in%` operator.
    </div>

1. Departed in summer (July, August, and September)

    ```{r filterex4, exercise = TRUE}
    ```
    ```{r filterex4-solution}
    filter(flights, 6 < month, month < 10)
    ```

    <div id="filterex4-hint">
    **Hint:** When converted to numbers, July, August, and September become 7, 8, and 9.
    </div>

1. Arrived more than two hours late, but didn't leave late

    ```{r filterex5, exercise = TRUE}
    ```
    ```{r filterex5-solution}
    filter(flights, arr_delay > 120, dep_delay <= 0)
    ```

    <div id="filterex5-hint">
    **Hint:** Remember that departure and arrival delays are recorded in     _minutes_.
    </div>

1. Were delayed more than an hour, but made up more than 30 minutes in flight

    ```{r filterex6, exercise = TRUE}
    ```
    ```{r filterex6-solution}
    filter(flights, dep_delay > 60, (dep_delay - arr_delay) > 30)
    ```

    <div id="filterex6-hint">
    **Hint:** The time a plane makes up is `dep_delay - arr_delay`.
    </div>

1. Departed between midnight and 6am (inclusive)

    ```{r filterex7, exercise = TRUE}
    ```
    ```{r filterex7-solution}
    filter(flights, dep_time <= 600 | dep_time == 2400)
    ```

    <div id="filterex7-hint">
    **Hint:** Don't forget flights that left at exactly midnight (`2400`). This is a good case for an "or" operator.
    </div>

### Exercise 2

Another useful dplyr filtering helper is `between()`. What does it do? Can you use `between()` to simplify the code needed to answer the previous challenges?

```{r filterex8, exercise = TRUE}
?between
```

### Exercise 3

How many flights have a missing `dep_time`? What other variables are missing? What might these rows represent?

```{r filterex9, exercise = TRUE}
```
```{r filterex9-solution}
filter(flights, is.na(dep_time))
```

<div id="filterex9-hint">
**Hint:** This is a good case for `is.na()`.
</div>

```{r filterex9-check}
"Flights with a missing departure time are probably cancelled flights."
```

### Exercise 4

Why is `NA ^ 0` not missing? Why is `NA | TRUE` not missing?
Why is `FALSE & NA` not missing? Can you figure out the general
rule?  (`NA * 0` is a tricky counterexample!)

```{r filterex10, exercise = TRUE}
```
```{r filterex10-hint-1}
# any number with a zero exponent is equal to one
NA ^ 0
```

```{r filterex10-hint-2}
# unknown value or true evaluates to true
# (because if one operand of "or" is true, we can be sure the result is true)
NA | TRUE
```

```{r filterex10-hint-3}
# false and unknown value evaluates to false
# (because if one operand of "and" is true, we can be sure the result is false)
FALSE & NA
```

```{r filterex10-hint-4}
# this is not a logical comparison, it's a numerical calculation involving an
# unknown value, thus resulting in an unknown value
NA * 0
```

```{r setup3, include=FALSE}
library(learnr)
library(tidyverse)
library(nycflights13)
library(Lahman)
tutorial_options(
  exercise.timelimit = 60,
  # A simple checker function that just returns the message in the check chunk
  exercise.checker = function(check_code, ...) {
    list(
      message = eval(parse(text = check_code)),
      correct = logical(0),
      type = "info",
      location = "append"
    )
  }
)
knitr::opts_chunk$set(error = TRUE)
```

## III. Summarizing Data

In this tutorial, you will learn how to summarise a table of data, including:

* How to summarise tables with `summarise()`
* How to recognize the most useful families of functions to combine with `summarise()`
* How to combine multiple dplyr operations with the pipe, `%>%`
* How to compute counts of observations with `n()`
* How to summarise groups of observations with `group_by()` and `summarise()`

The readings in this tutorial follow [_R for Data Science_](http://r4ds.had.co.nz/), section 5.6.

### Setup

To practice these skills, we will use the `flights` data set from the nycflights13 package, which you met in [Data Basics](https://learnr-examples.shinyapps.io/ex-data-basics). This data frame comes from the US [Bureau of Transportation Statistics](http://www.transtats.bts.gov/DatabaseInfo.asp?DB_ID=120&Link=0) and contains all `r format(nrow(nycflights13::flights), big.mark = ",")` flights that departed from New York City in 2013. It is documented in `?flights`.

To visualize the data, we will use the ggplot2 package that you met in [Data Visualization Basics](https://rstudio.cloud/learn/primers/1.1).

I've preloaded the packages for this tutorial with

```{r eval = FALSE}
library(tidyverse) # loads dplyr, ggplot2, and others
library(nycflights13)
```

## Summarise groups with summarise()

### summarise()

`summarise()` collapses a data frame to a single row of summaries. You get to choose how many summaries appear in the row and how they are computed:

```{r summarize}
summarise(flights, delay = mean(dep_delay, na.rm = TRUE),
                  total =  sum(dep_delay, na.rm = TRUE))
```

(We'll come back to what that `na.rm = TRUE` means very shortly.)

Notice that the syntax of `summarise()` is similar to `mutate()`. As with `mutate()`, you give summarise:

1. The name of a data frame to transform
2. One or more column names to appear in the transformed output. Each column name is set equal to the R expression that will generate the content of the column.

The main difference between `summarise()` and `mutate()` is the type of function that you use to generate the new columns. `mutate()` takes functions that return an entire vector of output (to append to the original data frame). `summarise()` takes functions that return a single value (or summary). These values will appear in a new data frame that has only one row.

### group_by()

`summarise()` is not terribly useful unless you pair it with `group_by()`. `group_by()` changes the unit of analysis of the data frame: it assigns observations in the data frame to separate groups, and it instructs dplyr to apply functions separately to each group. `group_by()` assigns groups by grouping together observations that have the same combinations of values for the variables that you pass to `group_by()`.

For example, the `summarise()` code above computes the average delay for the entire data set. If we apply exactly the same code to a data set that has been grouped by date (i.e. the unique combinations of `year`, `month`, and `day`), we get the average delay per date. Click "Run Code" to see what I mean:

```{r summarise, exercise = TRUE, exercise.eval = FALSE}
by_day <- group_by(flights, year, month, day)
summarise(by_day, delay = mean(dep_delay, na.rm = TRUE),
                  total = sum(dep_delay, na.rm = TRUE))
```

```{r summarise-check}
"Good job!"
```


### Exercise 1

Which carrier has the worst delays? Challenge: can you disentangle the effects of bad airports vs. bad carriers? Why/why not? (Hint: think about `flights %>% group_by(carrier, dest) %>% summarise(n())`)

```{r summariseex4, exercise = TRUE}
```

```{r summariseex4-solution}
flights %>%
  group_by(carrier) %>%
  summarise(avg_delay = mean(dep_delay, na.rm = TRUE)) %>%
  mutate(rank = min_rank(desc(avg_delay))) %>%
  filter(rank == 1)
```

<div id="summariseex4-hint">
**Hint:** Use`min_rank(desc(avg_delay))` to rank `avg_delay` (for example) such that the largest delay receives rank one.
</div>

```{r summariseex4-check}
"Great work! Frontier airlines (`F9`) was the highest average departure delay."
```

### Exercise 2

For each plane, count the number of flights before the first delay of greater than 1 hour.

```{r summariseex5, exercise = TRUE}
```

```{r summariseex5-solution}
flights %>%
  filter(!is.na(dep_delay)) %>%
  group_by(tailnum) %>%
  mutate(big_delay = dep_delay > 60,
         before = !cumany(big_delay)) %>%
  summarise(sum(before))
```

<div id="summariseex5-hint">
**Hint:** One strategy would be to:
* filter out all rows where `dep_delay` is `NA`.
* Then group by plane,
* create a variable that tests whether each flight was delayed longer than an hour
* create a variable that identifies flights that occur before the first big delay with `!cumany()`
* sum up the number of trues
</div>

```{r summariseex5-check}
"Great work! That was tough. Be sure you understand each of the steps and functions involved."
```

### Grouping by multiple variables

When you group by multiple variables, each summary peels off one level of the grouping. That makes it easy to progressively roll up a dataset. Run the code below and inspect each result to see how its grouping criteria has changed (the grouping criteria is displayed at the top of the tibble).

```{r unwrap, exercise = TRUE}
daily <- group_by(flights, year, month, day)
(per_day <- summarise(daily, total = sum(dep_delay, na.rm = TRUE)))
(per_month <- summarise(per_day, total = sum(total, na.rm = TRUE)))
(per_year  <- summarise(per_month, total = sum(total, na.rm = TRUE)))
```

Be careful when you progressively roll up summaries: it's OK for sums and counts, but you need to think about weighting means and variances, and it's not possible to do it exactly for rank-based statistics like the median. In other words, the sum of groupwise sums is the overall sum, but the median of groupwise medians is not the overall median.

### Ungrouping

If you need to remove grouping, and return to operations on ungrouped data, use `ungroup()`.

```{r echo = FALSE}
daily <- group_by(flights, year, month, day)
```

```{r}
daily <- ungroup(daily) # no longer grouped by date
summarise(daily, total = sum(dep_delay, na.rm = TRUE))  # all flights
```

### Groups and dplyr

`group_by()` also works with the other dplyr functions; dplyr will apply `filter()`, `select()`, `arrange()`, and `mutate()` in a groupwise fashion to grouped data. However, `group_by()` is the most useful when combined with `summarise()`. Together `group_by()` and `summarise()` provide one of the tools that you'll use most commonly when working with dplyr: grouped summaries. But before we go any further with this, we need to introduce a powerful new idea: the pipe.

## Combining multiple operations

### Multiple steps

Imagine that we want to explore the relationship between the distance and average delay for each destination in `flights`. Using what you know about dplyr, you might write code like this:

```{r, fig.width = 6, message = FALSE}
by_dest <- group_by(flights, dest)
delay <- summarise(by_dest,
  count = n(),
  dist = mean(distance, na.rm = TRUE),
  delay = mean(arr_delay, na.rm = TRUE)
)
delay <- filter(delay, count > 20, dest != "HNL")
ggplot(data = delay, mapping = aes(x = dist, y = delay)) +
  geom_point(aes(size = count), alpha = 1/3) +
  geom_smooth(se = FALSE)
```

The code works, and we find an interesting effect: It looks like delays increase with distance up to ~750 miles and then decrease. Maybe as flights get longer there's more ability to make up delays in the air?

Now let's look at how we prepared the data. There are three steps:

1.  Group flights by destination.

1.  Summarise to compute distance, average delay, and number of flights.

1.  Filter to remove noisy points and Honolulu airport, which is almost twice as far away as the next closest airport.

This code is a little frustrating to write because we have to give each intermediate data frame a name, even though we don't care about it. Naming things is hard, so this slows down our analysis.

### Pipes

There's another way to tackle the same problem. We can turn the code into a pipe with the pipe operator, `%>%`:

```{r}
delays <- flights %>%
  group_by(dest) %>%
  summarise(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm = TRUE)
  ) %>%
  filter(count > 20, dest != "HNL")
```

Behind the scenes, `x %>% f(y)` turns into `f(x, y)`, and `x %>% f(y) %>% g(z)` turns into `g(f(x, y), z)` and so on. You can use the pipe to rewrite multiple operations in a way that you can read left-to-right, top-to-bottom.

This focuses on the transformations, not what's being transformed, which makes the code easier to read. You can read it as a series of imperative statements: group, then summarise, then filter. As suggested by this reading, a good way to pronounce `%>%` when reading code is "then".

We'll use piping frequently from now on because it considerably improves the readability of code, and we'll come back to it in more detail in [Pipes]().

The pipe is a defining feature of the tidyverse: packages in the tidyverse all contain functions that are designed to work with the pipe. The only exception is ggplot2: it was written before the pipe was discovered. Unfortunately, the next iteration of ggplot2, ggvis, which does use the pipe, isn't quite ready for prime time yet.


## Useful summary functions {#summarise-funs}

### Aggregating functions

You can get a long way with means and sum; but R provides many other useful functions to use with summary. Each of these functions acts as an **aggregating function**: it takes a vector of values and returns a single value.

Let's demonstrate some of the most useful aggregating functions with this data set, which removes flights that have no delay information (because they were cancelled).

```{r}
not_cancelled <- flights %>%
  filter(!is.na(dep_delay), !is.na(arr_delay))
```

*   **Measures of location**: we've used `mean(x)`, but `median(x)` is also useful. The mean is the sum divided by the length; the median is a value where 50% of `x` is above it, and 50% is below it.

    It's sometimes useful to combine aggregation with logical subsetting. We haven't talked about this sort of subsetting yet, but you'll learn more about it in [Subsetting]().

    ```{r}
    not_cancelled %>%
      group_by(year, month, day) %>%
      summarise(
        avg_delay1 = mean(arr_delay),
        avg_delay2 = mean(arr_delay[arr_delay > 0]) # the average positive delay
      )
    ```

*   **Measures of spread**: `sd(x)`, `IQR(x)`, `mad(x)`. The mean squared deviation, or standard deviation or sd for short, is the standard measure of spread. The interquartile range `IQR()` and median absolute deviation `mad(x)`are robust equivalents that may be more useful if you have outliers.

    ```{r}
    # Why is distance to some destinations more variable than to others?
    not_cancelled %>%
      group_by(dest) %>%
      summarise(distance_sd = sd(distance)) %>%
      arrange(desc(distance_sd))
    ```

*   **Measures of rank**: `min(x)`, `quantile(x, 0.25)`, `max(x)`. Quantiles are a generalisation of the median. For example, `quantile(x, 0.25)` will find a value of `x` that is greater than 25% of the values, and less than the remaining 75%.

    ```{r}
    # When do the first and last flights leave each day?
    not_cancelled %>%
      group_by(year, month, day) %>%
      summarise(
        first = min(dep_time),
        last = max(dep_time)
      )
    ```

*   **Measures of position**: `first(x)`, `nth(x, 2)`, `last(x)`. These work similarly to `x[1]`, `x[2]`, and `x[length(x)]` but let you set a default value if that position does not exist (i.e. you're trying to get the 3rd element from a group that only has two elements). For example, we can find the first and last departure for each day:

    ```{r}
    not_cancelled %>%
      group_by(year, month, day) %>%
      summarise(
        first_dep = first(dep_time),
        last_dep = last(dep_time)
      )
    ```

    These functions are complementary to filtering on ranks. Filtering gives you all variables, with each observation in a separate row:

    ```{r}
    not_cancelled %>%
      group_by(year, month, day) %>%
      mutate(r = min_rank(desc(dep_time))) %>%
      filter(r %in% range(r))
    ```

*   **Counts**: In the next section, you will meet `n()`, which takes no arguments, and returns the size of the current group. You can count other useful quantities as well. To count the number of non-missing values, use `sum(!is.na(x))`. To count the number of distinct (unique) values, use `n_distinct(x)`.

    ```{r}
    # Which destinations have the most carriers?
    not_cancelled %>%
      group_by(dest) %>%
      summarise(carriers = n_distinct(carrier)) %>%
      arrange(desc(carriers))
    ```

*   **Counts and proportions of logical values**: `sum(x > 10)`, `mean(y == 0)`. When used with numeric functions, `TRUE` is converted to 1 and `FALSE` to 0. This makes `sum()` and `mean()` very useful: `sum(x)` gives the number of `TRUE`s in `x`, and `mean(x)` gives the proportion.

    ```{r}
    # How many flights left before 5am? (these usually indicate delayed
    # flights from the previous day)
    not_cancelled %>%
      group_by(year, month, day) %>%
      summarise(n_early = sum(dep_time < 500))
    # What proportion of flights are delayed by more than an hour?
    not_cancelled %>%
      group_by(year, month, day) %>%
      summarise(hour_perc = mean(arr_delay > 60))
    ```

### Exercise 3

Brainstorm at least 5 different ways to assess the typical delay characteristics of a group of flights. Consider the following scenarios:

* A flight is 15 minutes early 50% of the time, and 15 minutes late 50% of the time.

* A flight is always 10 minutes late.

* A flight is 30 minutes early 50% of the time, and 30 minutes late 50% of the time.

* 99% of the time a flight is on time. 1% of the time it's 2 hours late.

Which is more important: arrival delay or departure delay?

```{r summariseex1, exercise = TRUE}
```

<div id="summariseex1-hint">
**Hint:** Consider R's measures of location and measures of spread.
</div>


### Missing values

You may have wondered about the `na.rm` argument we used in a previous section. What happens if we don't set it?

```{r}
flights %>%
  group_by(year, month, day) %>%
  summarise(mean = mean(dep_delay))
```

We get a lot of missing values! That's because aggregation functions obey the usual rule of missing values: if there's any missing value in the input, the output will be a missing value. Fortunately, all aggregation functions have an `na.rm` argument which removes the missing values prior to computation:

```{r}
flights %>%
  group_by(year, month, day) %>%
  summarise(mean = mean(dep_delay, na.rm = TRUE))
```

In this case, where missing values represent cancelled flights, we could also tackle the problem by first removing the cancelled flights, as we did to create `not_cancelled`.

```{r}
not_cancelled <- flights %>%
  filter(!is.na(dep_delay), !is.na(arr_delay))
not_cancelled %>%
  group_by(year, month, day) %>%
  summarise(mean = mean(dep_delay))
```

### Exercise 4

Our definition of cancelled flights (`is.na(dep_delay) | is.na(arr_delay)`) is slightly suboptimal. Why? Which is the most important column?

## Counts

### n()

Whenever you do any aggregation, it's always a good idea to include either a count (`n()`), or a count of non-missing values (`sum(!is.na(x))`). That way you can check that you're not drawing conclusions based on very small amounts of data. For example, let's look at the planes (identified by their tail number) that have the highest average delays:

```{r}
delays <- not_cancelled %>%
  group_by(tailnum) %>%
  summarise(
    delay = mean(arr_delay)
  )
ggplot(data = delays, mapping = aes(x = delay)) +
  geom_freqpoly(binwidth = 10)
```

Wow, there are some planes that have an _average_ delay of 5 hours (300 minutes)!

The story is actually a little more nuanced. We can get more insight if we draw a scatterplot of number of flights vs. average delay. Fill in the blank code below to compute and then plot the number of flights by the mean arrival delay (`arr_delay`).

```{r delays, exercise = TRUE}
# delays <- not_cancelled %>%
#   group_by(tailnum) %>%
#   summarise(
#     delay = _________,
#     n = n()
#   )
#
# ggplot(data = delays, mapping = aes(x = n, y = delay)) +
#   geom_point(alpha = 1/10)
```

```{r delays-solution}
delays <- not_cancelled %>%
  group_by(tailnum) %>%
  summarise(
    delay = mean(arr_delay),
    n = n()
  )
ggplot(data = delays, mapping = aes(x = n, y = delay)) +
  geom_point(alpha = 1/10)
```

Not surprisingly, there is much greater variation in the average delay when there are few flights. The shape of this plot is very characteristic: whenever you plot a mean (or other summary) vs. group size, you'll see that the variation decreases as the sample size increases.

### Accounting for variation based on sample size

When looking at this sort of plot, it's often useful to filter out the groups with the smallest numbers of observations, so you can see more of the pattern and less of the extreme variation in the smallest groups. This is what the following code does, as well as showing you a handy pattern for integrating ggplot2 into dplyr flows. It's a bit painful that you have to switch from `%>%` to `+`, but once you get the hang of it, it's quite convenient.

```{r echo = FALSE}
delays <- not_cancelled %>%
  group_by(tailnum) %>%
  summarise(
    delay = mean(arr_delay),
    n = n()
  )
```


```{r}
delays %>%
  filter(n > 25) %>%
  ggplot(mapping = aes(x = n, y = delay)) +
    geom_point(alpha = 1/10)
```

--------------------------------------------------------------------------------

RStudio tip: a useful keyboard shortcut is Cmd/Ctrl + Shift + P. This resends the previously sent chunk from the editor to the console. This is very convenient when you're (e.g.) exploring the value of `n` in the example above. You send the whole block once with Cmd/Ctrl + Enter, then you modify the value of `n` and press Cmd/Ctrl + Shift + P to resend the complete block.

--------------------------------------------------------------------------------

### Sample size, average performance, and rank

There's another common variation of this type of pattern. Let's look at how the average performance of batters in baseball is related to the number of times they're at bat. Here I use data from the __Lahman__ package to compute the batting average (number of hits / number of attempts) of every major league baseball player.

When I plot the skill of the batter (measured by the batting average, `ba`) against the number of opportunities to hit the ball (measured by at bat, `ab`), you see two patterns:

1.  As above, the variation in our aggregate decreases as we get more data points.

2.  There's a positive correlation between skill (`ba`) and opportunities to hit the ball (`ab`). This is because teams control who gets to play, and obviously they'll pick their best players.

```{r}
# Convert to a tibble so it prints nicely
batting <- as_tibble(Lahman::Batting)
batters <- batting %>%
  group_by(playerID) %>%
  summarise(
    ba = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),
    ab = sum(AB, na.rm = TRUE)
  )
batters %>%
  filter(ab > 100) %>%
  ggplot(mapping = aes(x = ab, y = ba)) +
    geom_point() +
    geom_smooth(se = FALSE)
```

This also has important implications for ranking. If you look closely, the people with the best batting averages are clearly lucky, not skilled.

You can find a good explanation of this problem at <http://varianceexplained.org/r/empirical_bayes_baseball/> and <http://www.evanmiller.org/how-not-to-sort-by-average-rating.html>.

### count()

Counts are so useful that dplyr provides a simple helper if all you want is a count:

```{r}
not_cancelled %>%
  count(dest)
```

    You can optionally provide a weight variable. For example, you could use this to "count" (sum) the total number of miles a plane flew:

```{r}
not_cancelled %>%
  count(tailnum, wt = distance)
```

### Exercise 5

Come up with another approach that will give you the same output as `not_cancelled %>% count(dest)` and `not_cancelled %>% count(tailnum, wt = distance)` (without using `count()`).

```{r summariseex2, exercise = TRUE}
```
```{r summariseex2-solution}
not_cancelled %>%
  group_by(dest) %>%
  summarise(n = n())
not_cancelled %>%
  group_by(tailnum) %>%
  summarise(n = sum(distance))
```

<div id="summariseex2-hint">
**Hint:** Consider the tools at your disposal" `group_by()`, `summarise()`, `n()`, `sum()`, and `?count`
</div>

```{r summariseex2-check}
"Excellent Job! This was a tricky one, but you can now see that `count()` is a handy short cut for `group_by()` + `summarise()` + `n()` (or `sum()`)."
```

### Exercise 6

What does the `sort` argument to `count()` do. When might you use it?

```{r summariseex6, exercise = TRUE}
?count
```

### Exercise 7

Look at the number of cancelled flights per day. Is there a pattern? Is the proportion of cancelled flights related to the average delay?

```{r summariseex3, exercise = TRUE}
# Task 1
# begin with a variable that shows the day of the year
# flights %>%
#   mutate(date = as.Date(paste(year, month, day, sep = "-"))) %>%
# create a variable that shows whether a flight is cancelled
# group by day
# create a summary by counting up the number of flights where cancelled is TRUE
# Plot the result against day
# Task 2
# recreate the grouped data above
# create a summary by taking the mean of cancelled variable
# ...as well as the average delay
# plot one against the other
```

```{r summariseex3-solution}
flights %>%
  mutate(date = as.Date(paste(year, month, day, sep = "-"))) %>%
  mutate(cancelled = is.na(dep_delay) | is.na(arr_delay)) %>%
  group_by(date) %>%
  summarise(n = sum(cancelled)) %>%
  ggplot(aes(x = date, y = n)) +
    geom_point() +
    geom_smooth()
flights %>%
  mutate(date = as.Date(paste(year, month, day, sep = "-"))) %>%
  mutate(cancelled = is.na(dep_delay) | is.na(arr_delay)) %>%
  group_by(date) %>%
  summarise(prop = mean(cancelled), avg_delay = mean(dep_delay, na.rm = TRUE)) %>%
  ggplot(aes(x = prop, y = avg_delay)) +
    geom_point()
```

<div id="summariseex3-hint">
**Hint:** Don't forget to use `na.rm = TRUE` where appropriate.
</div>

```{r summariseex3-check}
"Wow! You did awesome."
```